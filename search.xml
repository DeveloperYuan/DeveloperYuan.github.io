<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python读文件报错解决]]></title>
    <url>%2F2019%2F06%2F30%2Fpython-read-file-error-solution%2F</url>
    <content type="text"><![CDATA[python读取文件时提示UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 205: illegal multibyte sequence 解决方案112345#!/usr/bin/python3# -*- coding:utf8 -*-import codecs# 以指定编码方式方式打开文件open("filename",'r',encoding="utf8") 解决方案212345# 以二进制形式打开文件with open("test.txt", "rb") as f: for line in f: line = line.decode("utf-8") # 读取时选择指定的解码方式 some_code_to_process_line()]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网协议入门]]></title>
    <url>%2F2019%2F06%2F30%2Fintroduction-to-internet-protocol%2F</url>
    <content type="text"><![CDATA[由于本人不是CS专业出身，所以对计算机网络的基础知识了解不多，一直搞不清楚各种协议的由来以及各种协议属于哪一层，现写下这篇文章，供大家一起参考学习。 一、网络层次划分要了解各种该协议的作用，首先必须要请出去计算机网络的层次划分。1978年，国际标准化组织（ISO）提出了“开放系统互联网参考模型”（Open System Interconnection/Reference Model, OSI/RM）。该模型将计算机网络结构的通信协议分为七层。除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议。 物理层：把数据转化为传输介质上的电子流或模拟脉冲，并且监视数据的传输 数据链路层：提供与网络适配器相连的接口，维护子网的逻辑链接 网络层：支持逻辑寻址与路由选择 传输层：为网络提供错误控制和数据流控制 会话层：在计算机的通信应用程序之间建立会话 表示层：把数据转化为标准格式，管理数据加密与压缩 应用层：为应用程序提供网络接口，支持文件传输、通信等功能的网络应用 每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。 大家都遵守的规则，就叫做”协议”（protocol）。 互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。 二、各层存在的协议2.1 物理层（实体层）“实体层”，就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号 2.2 数据链接层“数据链接层”在”实体层”的上方，确定了0和1的分组方式。 以太网协议早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做“以太网”（Ethernet）的协议，占据了主导地位。 以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。 “标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。 “标头”的长度，固定为18字节。“数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。 2.3 网络层“网络层”的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。 IP协议规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。 目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。 IP数据包也分为”标头”和”数据”两个部分。 IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。 ARP协议有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 2.4 传输层“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。 UDP协议UDP协议的格式几乎就是在数据前面，加上端口号。 TCP协议TCP协议可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。 2.5 应用层“应用层”的作用，就是规定应用程序的数据格式。 电子邮件传输（SMTP）文件传输协议（FTP）网络远程访问协议（Telnet）HTTP]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>protocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法总结(javascript)]]></title>
    <url>%2F2019%2F06%2F29%2Fjavascript-sort-algorithm-summarize%2F</url>
    <content type="text"><![CDATA[由于一直理不清楚各种不同的排序算法的原理以及他们之间的区别，所以特此写下此文，希望不要在面试问到有关算法的时候一问三不知。 冒泡排序（Bubble Sort）冒泡排序应该是所有排序算法里面最经典的一种了。记得本科学C语言的时候还学过。 冒泡排序的原理很简单，就是遍历数组中的所有元素，每个元素和其余元素进行大小比较，如果元素的位置与排序方向不符，则交换元素位置。这个算法名字的由来是越小的元素会随着交换的过程慢慢“浮”到数组顶端。 具体算法描述如下： 比较相邻的元素。如果第一个比第二个大，就交换它们两个；对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；针对所有的元素重复以上的步骤，除了最后一个；重复步骤1~3，直到排序完成。 123456789101112131415// 原始冒泡排序算法function bubbleSort(arr) &#123; var len = arr.length; var tmp; console.time('原始冒泡排序耗时'); for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; console.timeEnd('原始冒泡排序耗时'); return arr;&#125; 改进冒泡排序1： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 123456789101112131415161718192021// 改进后冒泡排序方法1// 加入冒泡标识位pos// pos为上一次冒泡位置function bubbleSort1(arr) &#123; var i = arr.length - 1; //初始时,最后位置保持不变 console.time('改进后冒泡排序一耗时'); while (i &gt; 0) &#123; var pos = 0; //每趟开始时,无记录交换 for (var j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; pos = j; //记录交换的位置 var tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; i = pos; //为下一趟排序作准备 &#125; console.timeEnd('改进后冒泡排序一耗时'); return arr;&#125; 改进冒泡排序2：传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。 12345678910111213141516171819202122232425// 改进后冒泡排序方法2// 每趟排序中进行正向和反向两遍冒泡// 一次可以得到两个最终值(最大者和最小者)function bubbleSort2(arr) &#123; var low = 0; var high = arr.length - 1; // 设置变量的初始值 var tmp, j; console.time('改进后冒泡排序二耗时'); while (low &lt; high) &#123; for (j = low; j &lt; high; ++j) &#123; // 正向冒泡,找到最大者 if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; --high; // 修改high值, 前移一位 for (j = high; j &gt; low; --j) &#123; // 反向冒泡,找到最小者 if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = tmp; &#125; &#125; ++low; // 修改low值,后移一位 &#125; console.timeEnd('改进后冒泡排序二耗时'); return arr;&#125; 测试代码如下（测试环境为Chrome 61.0.3163.100，如无特殊说明下同）： 12345// 测试var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(bubbleSort(arr)); // 原始冒泡排序耗时: 0.02880859375ms [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]console.log(bubbleSort1(arr)); // 改进后冒泡排序一耗时: 0.00732421875ms [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]console.log(bubbleSort2(arr)); // 改进后冒泡排序二耗时: 0.01611328125ms [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 当输入的数据已经是正序时T(n) = O(n) 当输入的数据是反序时T(n) = O(n2) 平均情况：T(n) = O(n2) 选择排序（Selection Sort）选择排序是最符合我直觉的排序方法，同时也是最稳定的排序方法（时间复杂度稳定O(n2)）. 选择排序的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空；第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；n-1趟结束，数组有序化了。javascript代码实现如下： 12345678910111213141516171819202122232425// 选择排序算法function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; console.time('选择排序耗时'); for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; console.timeEnd('选择排序耗时'); return arr;&#125;// 测试var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(selectionSort(arr)); // 选择排序耗时: 0.02490234375ms// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 插入排序（Insertion Sort）插入排序的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中从后向前扫描；如果该元素（已排序）大于新元素，将该元素移到下一位置；重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；将新元素插入到该位置后；重复步骤2~5。 12345678910111213141516171819// 经典插入排序function insertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; console.time('插入排序耗时'); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; console.timeEnd('插入排序耗时'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 改进插入排序： 查找插入位置时使用二分查找的方式 12345678910111213141516171819202122232425262728// 改进后插入排序// 使用二分法查找插入位置function binaryInsertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; console.time('二分插入排序耗时'); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; array[j + 1] = array[j]; &#125; array[left] = key; &#125; console.timeEnd('二分插入排序耗时'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 最佳情况：输入数组按升序排列。T(n) = O(n) 最坏情况：输入数组按降序排列。T(n) = O(n2) 平均情况：T(n) = O(n2) 希尔排序（Shell Sort）1959年Shell发明；第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序然后取 d2(d2 &lt; d1)重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。 1234567891011121314151617181920212223// 希尔排序function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; console.time('希尔排序耗时:'); while (gap &lt; len / 5) &#123; // 动态定义间隔序列 gap = gap * 5 + 1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap / 5)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; arr[j + gap] = arr[j]; &#125; arr[j + gap] = temp; &#125; &#125; console.timeEnd('希尔排序耗时:'); return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(shellSort(arr)); // [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog n) 归并排序（Merge Sort）和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 具体算法描述如下： 把 n 个记录看成 n 个长度为 l 的有序子表进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。 1234567891011121314151617181920212223242526272829303132function mergeSort(arr) &#123;//采用自上而下的递归方法 var len = arr.length; if (len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right) &#123; var result = []; console.time('归并排序耗时'); while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); console.timeEnd('归并排序耗时'); return result;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(mergeSort(arr)); 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 快速排序（Quick Sort）快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法 (Divide-and-ConquerMethod)。 分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 利用分治法可将快速排序分为三步： 在数据集之中，选择一个元素作为”基准”（pivot）。所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 1234567891011121314151617181920212223//方法一function quickSort(array, left, right) &#123; console.time('1.快速排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' &amp;&amp; typeof left === 'number' &amp;&amp; typeof right === 'number') &#123; if (left &lt; right) &#123; var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) &#123; if (array[j] &lt;= x) &#123; i++; temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; quickSort(array, left, i - 1); quickSort(array, i + 1, right); &#125; console.timeEnd('1.快速排序耗时'); return array; &#125; else &#123; return 'array is not an Array or left or right is not a number!'; &#125;&#125; 123456789101112131415161718//方法二var quickSort2 = function(arr) &#123; console.time('2.快速排序耗时'); if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125;console.timeEnd('2.快速排序耗时'); return quickSort2(left).concat([pivot], quickSort2(right));&#125;; 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*方法说明：堆排序@param array 待排序数组*/function heapSort(array) &#123; console.time('堆排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; console.timeEnd('堆排序耗时'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/function heapify(arr, x, len) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number') &#123; var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125; 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 计数排序（Counting Sort）具体算法描述如下： 找出待排序的数组中最大和最小的元素；统计数组中每个值为i的元素出现的次数，存入数组C的第i项；对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 12345678910111213141516171819202122// 计数排序function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; console.time('计数排序耗时'); for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; for (var k = len - 1; k &gt;= 0; k--) &#123; B[C[array[k]] - 1] = array[k]; C[array[k]]--; &#125; console.timeEnd('计数排序耗时'); return B;&#125; 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k) 桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 桶排序 (Bucket sort)或所谓的箱排序的原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。 排序过程： 假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序将各个桶中的数据有序的合并起来 123456789101112131415161718192021222324252627282930313233343536/*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) &#123; if (array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); console.time('桶排序耗时'); for (var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; &#125; space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if (buckets[index]) &#123; // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; console.timeEnd('桶排序耗时'); return result;&#125; 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2) 基数排序（Radix Sort）基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； 基数排序的主要思路是,将所有待比较数值(注意,必须是正整数)统一为同样的数位长度,数位较短的数前面补零. 然后, 从最低位开始, 依次进行一次稳定排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 具体算法描述如下： 取得数组中的最大数，并取得位数arr为原始数组，从最低位开始取每个位组成radix数组对radix进行计数排序（利用计数排序适用于小范围数的特点） 1234567891011121314151617181920212223242526272829303132333435363738/** * 基数排序适用于： * (1)数据范围较小，建议在小于1000 * (2)每个数值都要大于等于0 * @author xiazdong * @param arr 待排序数组 * @param maxDigit 最大位数 *///LSD Radix Sortfunction radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; var counter = []; console.time('基数排序耗时'); for (var i = 0; i &lt; maxDigit; i++ , dev *= 10, mod *= 10) &#123; for (var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if (counter[bucket] == null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for (var j = 0; j &lt; counter.length; j++) &#123; var value = null; if (counter[j] != null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; console.timeEnd('基数排序耗时'); return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(radixSort(arr, 2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 基数排序有两种方法： MSD 从高位开始进行排序LSD 从低位开始进行排序 参考链接： 十大经典排序算法总结（JavaScript描述）(http://www.cnblogs.com/jztan/p/5878630.html)]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript小技巧]]></title>
    <url>%2F2019%2F06%2F29%2Fjavascript-tips%2F</url>
    <content type="text"><![CDATA[0.前言本文参考网上的博客文章以及自己平时写项目时的一些心得体会总结的一些JavaScript代码的小技巧，会不定期更新，需要的朋友可以收藏一下。 1.Dom操作在JavaScript的代码中，原则上是涉及到的Dom操作越少越好，因为Dom操作是非常耗费性能的。以下两份代码在Chrome浏览器（版本61.0.3163.79，64位） 中测试。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;JavaScript Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var count = 0; console.time(); for (var i = 0; i &lt; document.getElementsByTagName('li').length; i++) &#123; count++; &#125; console.timeEnd();//0.35009765625ms &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;JavaScript Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var count = 0; console.time(); for (var i = 0; i &lt; document.getElementsByTagName('div').length; i++) &#123; count++; &#125; console.timeEnd();//0.0849609375ms &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同理，如果用JavaScript动态生成Dom元素，可以用拼接字符串+innerHTML的方法，不用 createElement+createTextNode的方法，尤其是在动态生成的Dom元素比较多的情况下。下面是测试代码，测试环境同上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;JavaScript Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;/ul&gt; &lt;script&gt; console.time(); var oUl = document.getElementsByTagName('ul')[0] for (var i = 0; i &lt; 100; i++) &#123; var oLi = document.createElement('li'); oLi.innerHTML = i; oUl.appendChild(oLi); &#125; console.timeEnd();//5.726806640625ms &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;JavaScript Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;/ul&gt; &lt;script&gt; console.time(); var oUl = document.getElementsByTagName('ul')[0]; sLi = ''; for (var i = 0; i &lt; 100; i++) &#123; sLi += '&lt;li&gt;'+i+'&lt;/li&gt;' &#125; oUl.innerHTML += sLi; console.timeEnd();//1.376953125ms &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.Dom事件一个简单的需求，比如想给ul下面的li加上点击事件，点击哪个li，就显示那个li的innerHTML。常规实现方法如下。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;JavaScript Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var oUl = document.getElementsByTagName('ul')[0]; var oLi = oUl.getElementsByTagName('li'); for (var i = 0, len = oLi.length; i &lt; len; i++) &#123; oLi[i].addEventListener('click', function()&#123; alert(this.innerHTML); &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 但是上述代码有两个问题： for循环，循环的是li，10个li就循环10次，绑定10次事件，100个就循环了100次，绑定100次事件。如果li不是本来就在页面上的，是js渲染的未来元素，上面的写法是无效的。事件委托的写法如下。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;JavaScript Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var oUl = document.getElementsByTagName('ul')[0]; oUl.addEventListener('click', function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.tagName.toLowerCase() == 'li') &#123; alert(target.innerHTML); &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.JavaScript对象深浅拷贝对于JavaScript对象的深浅拷贝，个人认为有以下区别: 无论是浅拷贝还是深拷贝都只针对引用数据类型（如Object，Array） 浅拷贝只是将对象的引用地址进行拷贝，改变拷贝值，并没有开辟新的栈。 深拷贝会开辟新的栈，两个对象指向两个不同的地址。 注意下面三段代码的区别。三段代码分别是浅拷贝，单层深拷贝以及深拷贝。 123456789101112131415161718192021222324252627282930313233343536373839//shallow clonevar me = &#123; 'name': 'DeveloperYuan', 'sex': 'male', 'age': 24 &#125;;var someone = me;someone.age = 25;console.log(someone);//&#123;name: "DeveloperYuan", sex: "male", age: 25&#125; console.log(someone);//&#123;name: "DeveloperYuan", sex: "male", age: 25&#125;//one-level deep clonevar me = &#123; 'name': 'DeveloperYuan', 'sex': 'male', 'age': 24, 'skills':['php', 'javascript', 'python']&#125;;var someone = Object.assign(&#123;&#125;, me);someone.name = 'passerby';console.log(me);//&#123;name: "DeveloperYuan", sex: "male", age: 24, 'skills':['php', 'javascript', 'python']&#125;console.log(someone);//&#123;name: "passerby", sex: "male", age: 24, 'skills':['php', 'javascript', 'python']&#125;someone.skills[0] = 'c++'; console.log(me); //&#123;name: "DeveloperYuan", sex: "male", age: 24, 'skills':['c++', 'javascript', 'python']&#125;console.log(someone); //&#123;name: "passerby", sex: "male", age: 24, 'skills':['c++', 'javascript', 'python']&#125;//deep clonefunction deepClone(obj) &#123; if (!obj &amp;&amp; typeof(obj) !== 'object') &#123; return; &#125; var cloneObj = obj.constructor === Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; if (obj[key] &amp;&amp; typeof(obj[key]) === 'object') &#123; cloneObj[key] = obj[key].constructor === Array ? [] : &#123;&#125;; cloneObj[key] = deepClone(obj[key]); &#125; else &#123; cloneObj[key] = obj[key]; &#125; &#125; &#125; return cloneObj;&#125;var me = &#123;'name':'DeveloperYuan', 'sex':'male', 'age':24, 'skills':['php', 'javascript', 'python']&#125;; var someone = deepClone(me);someone.skills[0] = 'c++'; console.log(me); //&#123;'name':'DeveloperYuan', 'sex':'male', 'age':24, 'skills':['php', 'javascript', 'python']&#125;; console.log(someone); //&#123;'name':'DeveloperYuan', 'sex':'male', 'age':24, 'skills':['c++', 'javascript', 'python']&#125;; 4.其他 扩展运算符（ spread ）扩展运算符（ spread ）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 123console.log(...[1, 2, 3]); // 1 2 3 console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5 [...document.querySelectorAll('div')]; // [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 数组去重(ES6) 1[...new Set([1,2,1,'1','12','12'])];//[1, 2, "1", "12"] 字符串转浮点数和整数 12345678a = '12.21';b = +a;//12.21c = a | 0;//12d = ~~a;//12使用模板字符串name = 'DeveloperYuan';time = new Date();const message = `Hello $&#123;name&#125;, it's $&#123;time&#125; now`; 结构 12const data = &#123;name:'dys', age:1&#125; const &#123;name, age&#125; = data 参考链接： 如何优雅的编写JavaScript代码个人小结–javascript实用技巧和写法建议]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python列表在循环中获取索引]]></title>
    <url>%2F2019%2F06%2F29%2Fpython-get-index-in-loop%2F</url>
    <content type="text"><![CDATA[用内建函数enumerate: 12for idx, val in enumerate(ints): print idx, val]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB去除重复数据]]></title>
    <url>%2F2019%2F06%2F29%2FMongoBD-distinct%2F</url>
    <content type="text"><![CDATA[核心思想：利用唯一索引，去除重复数据。（假设数据存于Weibo数据库中的old集合，且想把id字段重复的数据只保留一条） 新建立一个new集合，用于保存去重后的数据。且再new集合中建立唯一索引 1db.new.ensureIndex(&#123;&quot;id&quot;:1&#125;,&#123;&quot;unique&quot;:true&#125;) 将old集合中的数据使用mongoexport导出，然后mongoimport导入到new集合中 12mongoexport -d Weibo -c old -o data.datmongoimport -d Weibo -c new data.dat]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>distinct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python排序]]></title>
    <url>%2F2019%2F06%2F29%2Fpython-sort%2F</url>
    <content type="text"><![CDATA[基本排序sorted()返回新的list 12&gt;&gt;&gt; sorted([5, 2, 3, 1, 4])[1, 2, 3, 4, 5] list.sort()修改原有的list 1234&gt;&gt;&gt; a = [5, 2, 3, 1, 4]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 2, 3, 4, 5] list.sort()方法只能作用于列表，而 sorted()函数则接受任何可迭代对象 升降序list.sort() 和 sorted() 都接受一个布尔类型的 reverse 参数。这个参数用来标记是否使用降序排序 key函数从 Python 2.4 开始， list.sort() 和 sorted() 增加了一个 key 参数，该参数接受一个函数作为它的值，可以通过那个函数定义排序应该遵循的规则。key 参数的值必须是个函数，该函数有一个参数（列表元素）并且返回一个用来排序的 key（按这个 key 进行排序）。 12345678&gt;&gt;&gt; student_tuples = [ ('Chi', 'A', 15), ('Qin', 'B', 12), ('Xu', 'B', 10),]# 按列表元素（元组）的第3个值排序&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2]) # sort by age[('Xu', 'B', 10), ('Qin', 'B', 12), ('Chi', 'A', 15)] 可以利用这个参数巧妙的构造tuple来得到排序后的原索引 123&gt;&gt;&gt; my_list = [1,0,3,2,5]&gt;&gt;&gt; [i[0] for i in sorted(enumerate(my_list), key=lambda x:x[1])][1, 0, 3, 2, 4] Operator 模块函数由于 key 参数比较常用，所以 Python 内置了一些用来简单、快速生成相关函数的方法。 operator 模块提供了 itemgetter，attrgetter， 以及从 Python 2.6 开始提供的 methodcaller 函数。 12345678910111213141516171819202122232425&gt;&gt;&gt; from operator import itemgetter, attrgetter&gt;&gt;&gt; student_tuples = [ ('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10),]&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(2)) # 按元素索引排序[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]&gt;&gt;&gt; class Student: def __init__(self, name, grade, age): self.name = name self.grade = grade self.age = age def __repr__(self): return repr((self.name, self.grade, self.age))&gt;&gt;&gt; student_objects = [ Student('john', 'A', 15), Student('jane', 'B', 12), Student('dave', 'B', 10),]&gt;&gt;&gt; sorted(student_objects, key=attrgetter('age')) # 按对象属性排序[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 通过 operator 模块提供的函数还可以实现多重排序的功能。比如，先按 grade 排序再按 age 排序： 12345&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(1,2))[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]&gt;&gt;&gt; sorted(student_objects, key=attrgetter('grade', 'age'))[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)] methodcaller 函数可以让元素调用一个方法，然后按方法的返回值进行排序： 1234567&gt;&gt;&gt; words = ['b', 'a', 'abase', 'alfalfa']&gt;&gt;&gt; sorted(words, key=methodcaller('count', 'a')) # word.count('a')['b', 'a', 'abase', 'alfalfa']# 等价于&gt;&gt;&gt; sorted(words, key=lambda word: word.count('a'))['b', 'a', 'abase', 'alfalfa'] 平衡（Stability）排序和复杂排序从 Python 2.2 开始，排序将保证能够 stable。 这意味着当多个记录拥有相同的 key 时，它们的原始顺序将被保留。 123&gt;&gt;&gt; data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]&gt;&gt;&gt; sorted(data, key=itemgetter(0))[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)] 这个非常有用的特性可以用来实现包含多重排序（一会升序，一会降序）的复杂排序。比如，目标是实现 student 数据先以 grade 降序排序再以 age 升序排序： 1234567891011121314151617181920&gt;&gt;&gt; class Student: def __init__(self, name, grade, age): self.name = name self.grade = grade self.age = age def __repr__(self): return repr((self.name, self.grade, self.age))&gt;&gt;&gt; student_objects = [ Student('john', 'A', 15), Student('jane', 'B', 12), Student('dave', 'B', 10),]&gt;&gt;&gt; s = sorted(student_objects, key=attrgetter('age')) # sort on secondary key&gt;&gt;&gt; s[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]&gt;&gt;&gt; sorted(s, key=attrgetter('grade'), reverse=True) # now sort on primary key, descending[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] Python 使用的 Timsort 排序算法能够高效的实现多重排序。 类排序如果想给类排序的话，只需添加相关的比较方法。 12345678&gt;&gt;&gt; Student.__eq__ = lambda self, other: self.age == other.age&gt;&gt;&gt; Student.__ne__ = lambda self, other: self.age != other.age&gt;&gt;&gt; Student.__lt__ = lambda self, other: self.age &lt; other.age&gt;&gt;&gt; Student.__le__ = lambda self, other: self.age &lt;= other.age&gt;&gt;&gt; Student.__gt__ = lambda self, other: self.age &gt; other.age&gt;&gt;&gt; Student.__ge__ = lambda self, other: self.age &gt;= other.age&gt;&gt;&gt; sorted(student_objects)[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 一般情况下，只需定义上面6个比较操作就可以了。functools.total_ordering 类装饰器可以很方便就实现这个需求。 其他key 函数也可以不访问要排序对象的相关数据，访问外部资源也是可以的。比如，学生成绩存储在一个字典中，这个字典可以用来对学生名字进行排序： 1234&gt;&gt;&gt; students = ['dave', 'john', 'jane']&gt;&gt;&gt; newgrades = &#123;'john': 'F', 'jane':'A', 'dave': 'C'&#125;&gt;&gt;&gt; sorted(students, key=newgrades.__getitem__)['jane', 'dave', 'john'] Reference Posts: Huang Huang 的博客：python排序（Sorting Mini-HOW TO）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2F2019%2F06%2F29%2Fabout%2Fme%2F</url>
    <content type="text"><![CDATA[欢迎来到DeveloperYuan的博客。]]></content>
      <categories>
        <category>about</category>
      </categories>
      <tags>
        <tag>about</tag>
        <tag>me</tag>
      </tags>
  </entry>
</search>
